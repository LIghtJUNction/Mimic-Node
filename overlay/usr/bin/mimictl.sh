#!/bin/bash
set -e

MIMIC_NODE_ROOT="${MIMIC_NODE_ROOT:-"/"}"

# --- Configuration ---
SING_BOX_ETC="${MIMIC_NODE_ROOT}etc/sing-box/"
CONFIG_FILE="${SING_BOX_ETC}config.json"
STAGING_FILE="${SING_BOX_ETC}config.new"
PUBKEY_FILE="${SING_BOX_ETC}PUBKEY"
STAGING_PUBKEY_FILE="${SING_BOX_ETC}PUBKEY.new"
FLOW_TYPE="xtls-rprx-vision"

# --- Colors ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
NC='\033[0m'

# --- Logging ---
# All logs to stderr so stdout can be used for pipelining sensitive data (keys/uuids)
log_info() { echo -e "${GREEN}[INFO]${NC} $1" >&2; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1" >&2; }
log_err() { echo -e "${RED}[ERR]${NC} $1" >&2; }
die() {
    log_err "$1"
    exit 1
}

# --- Pre-flight Checks ---
command -v jq >/dev/null || die "jq is required but not installed."
command -v openssl >/dev/null || die "openssl is required but not installed."

# sing-box is optional for this script. If it's absent we will use explicit, logged fallbacks.
if command -v sing-box >/dev/null 2>&1; then
    HAS_SINGBOX=1
else
    HAS_SINGBOX=0
    log_warn "sing-box not found. Falling back to openssl/uuidgen-based implementations for key/uuid/sid generation. These fallbacks are explicit and logged."
fi

[ -f "$CONFIG_FILE" ] || die "Config file not found: $CONFIG_FILE"

# --- Helper Functions ---
generate_uuid() {
    # Prefer sing-box when available for compatibility.
    if [ "${HAS_SINGBOX:-0}" -eq 1 ]; then
        sing-box generate uuid
        return
    fi

    # Fallbacks (explicit)
    if command -v uuidgen >/dev/null 2>&1; then
        uuidgen
        return
    fi
    if [ -r /proc/sys/kernel/random/uuid ]; then
        cat /proc/sys/kernel/random/uuid
        return
    fi

    # Final fallback using openssl (will produce a RFC-like UUID)
    local u
    u="$(openssl rand -hex 16)"
    printf '%s-%s-%s-%s-%s\n' "${u:0:8}" "${u:8:4}" "${u:12:4}" "${u:16:4}" "${u:20:12}"
}

# generate_keypair: prints "<private> <public>"
generate_keypair() {
    if [ "${HAS_SINGBOX:-0}" -eq 1 ]; then
        sing-box generate reality-keypair | awk '{print $2}' | xargs echo
        return
    fi

    # Explicit fallback: generate random base64 strings using openssl and warn the user.
    # NOTE: These are NOT guaranteed to be compatible with reality protocol keys generated by sing-box;
    # they are an explicit fallback for testing/environments without sing-box.
    log_warn "sing-box not available; generating pseudo keypair with openssl (explicit fallback)."
    local priv pub
    priv="$(openssl rand -base64 32 | tr -d '\n')"
    pub="$(openssl rand -base64 32 | tr -d '\n')"
    echo "$priv $pub"
}

generate_sid() {
    if [ "${HAS_SINGBOX:-0}" -eq 1 ]; then
        sing-box generate rand 8 --hex
        return
    fi
    openssl rand -hex 8
}

# Apply staged files atomically and validate JSON
apply_staging() {
    if [ -f "$STAGING_FILE" ]; then
        # Validate JSON before applying
        if ! jq empty "$STAGING_FILE" >/dev/null 2>&1; then
            die "Staged config ($STAGING_FILE) is not valid JSON; aborting apply."
        fi

        # Backup current config if present
        if [ -f "$CONFIG_FILE" ]; then
            cp -a -- "$CONFIG_FILE" "${CONFIG_FILE}.mimic.bak" 2>/dev/null || log_warn "Failed to create config backup"
        fi

        mv -f -- "$STAGING_FILE" "$CONFIG_FILE"
        log_info "Applied staged config -> $CONFIG_FILE"
    fi

    if [ -f "$STAGING_PUBKEY_FILE" ]; then
        if [ -f "$PUBKEY_FILE" ]; then
            cp -a -- "$PUBKEY_FILE" "${PUBKEY_FILE}.mimic.bak" 2>/dev/null || log_warn "Failed to create PUBKEY backup"
        fi
        mv -f -- "$STAGING_PUBKEY_FILE" "$PUBKEY_FILE"
        log_info "Applied staged PUBKEY -> $PUBKEY_FILE"
    fi
}

# Determine input file: prefer STAGING_FILE if it exists (for batching), otherwise CONFIG_FILE
get_input_file() {
    if [ -f "$STAGING_FILE" ]; then
        echo "$STAGING_FILE"
    else
        echo "$CONFIG_FILE"
    fi
}

# Commands

cmd_gen_keys() {
    log_info "Generating reality keypair..."
    read -r priv pub <<<"$(generate_keypair)"
    if [ -z "$priv" ] || [ -z "$pub" ]; then
        die "Failed to generate keypair"
    fi

    local input_file
    input_file=$(get_input_file)
    local tmp_out
    tmp_out="$(mktemp)"

    # Stage new private key
    jq --arg pk "$priv" '.inbounds[0].tls.reality.private_key = $pk' "$input_file" >"$tmp_out" || die "jq failed during gen-keys"
    mv "$tmp_out" "$STAGING_FILE"

    printf '%s\n' "$pub" >"$STAGING_PUBKEY_FILE"

    apply_staging

    log_info "Generated keypair applied."
    echo "$pub"
}

cmd_add() {
    local email level no_apply
    no_apply=0

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
        --no-apply)
            no_apply=1
            shift
            ;;
        *)
            if [ -z "$email" ]; then
                email="$1"
            elif [ -z "$level" ]; then
                level="$1"
            else
                log_warn "Unexpected argument: $1"
            fi
            shift
            ;;
        esac
    done

    # Defaults
    level="${level:-0}"

    [ -n "$email" ] || die "Usage: $0 add [--no-apply] <email> [level]"

    local input_file
    input_file=$(get_input_file)

    # Ensure private key exists; if missing, generate keys first
    # Note: If we are in batch mode (STAGING exists), we check that.
    if [ "$(jq -r '.inbounds[0].tls.reality.private_key // ""' "$input_file")" = "" ]; then
        log_warn "No private key found in config; generating one now."
        # Call internal generation logic without applying immediately if possible,
        # but gen-keys command applies by default.
        # For simplicity, we just run gen-keys which will update CONFIG or create STAGING.
        cmd_gen_keys >/dev/null
        # After gen-keys, STAGING might have consumed CONFIG or be new. Re-eval input file.
        input_file=$(get_input_file)
    fi

    local uuid sid name
    uuid="$(generate_uuid)" || die "Failed to generate uuid"
    sid="$(generate_sid)" || die "Failed to generate sid"
    name="${email}:${sid}:${level}"

    local tmp_out
    tmp_out="$(mktemp)"

    # Append user and ensure sid is in short_id array (unique)
    # Using input_file as source allows chaining changes
    jq --arg name "$name" --arg uuid "$uuid" --arg flow "$FLOW_TYPE" --arg sid "$sid" \
        '.inbounds[0].users += [{"name": $name, "uuid": $uuid, "flow": $flow}] | (.inbounds[0].tls.reality.short_id) |= ((. // []) + [$sid] | unique )' \
        "$input_file" >"$tmp_out" || die "jq failed during add"

    mv "$tmp_out" "$STAGING_FILE"

    if [ "$no_apply" -eq 1 ]; then
        log_info "Staged user: $name (uuid: $uuid) - waiting for apply"
    else
        apply_staging
        log_info "Added user: $name (uuid: $uuid)"
    fi
    printf 'uuid: %s\nsid: %s\n' "$uuid" "$sid"
}

cmd_del() {
    local email no_apply
    no_apply=0

    while [[ $# -gt 0 ]]; do
        case $1 in
        --no-apply)
            no_apply=1
            shift
            ;;
        *)
            email="$1"
            shift
            ;;
        esac
    done

    [ -n "$email" ] || die "Usage: $0 del [--no-apply] <email>"

    local input_file
    input_file=$(get_input_file)

    # Check if user exists
    if ! jq -e --arg email "$email" '.inbounds[0].users[] | select(.name | startswith($email + ":"))' "$input_file" >/dev/null; then
        die "User with email '$email' not found."
    fi

    log_info "Removing user(s) with email: $email"

    local tmp_out
    tmp_out="$(mktemp)"

    jq --arg email "$email" '
        .inbounds[0].users |= map(select(.name | startswith($email + ":") | not))
    ' "$input_file" >"$tmp_out" || die "jq failed during del"

    mv "$tmp_out" "$STAGING_FILE"

    if [ "$no_apply" -eq 1 ]; then
        log_info "Staged deletion for: $email"
    else
        apply_staging
        log_info "Deleted user: $email"
    fi
}

cmd_reset() {
    local email no_apply
    no_apply=0

    while [[ $# -gt 0 ]]; do
        case $1 in
        --no-apply)
            no_apply=1
            shift
            ;;
        *)
            email="$1"
            shift
            ;;
        esac
    done

    [ -n "$email" ] || die "Usage: $0 reset [--no-apply] <email>"

    local input_file
    input_file=$(get_input_file)

    # 1. Find user to get current info
    local user_entry
    user_entry=$(jq -r --arg email "$email" '.inbounds[0].users[] | select(.name | startswith($email + ":"))' "$input_file")

    if [ -z "$user_entry" ]; then
        die "User not found: $email"
    fi

    # Parse current name format: email:sid:level
    local name
    name=$(echo "$user_entry" | jq -r '.name')

    # Extract level (last field) and old sid (second to last field)
    local level old_sid
    level=$(echo "$name" | rev | cut -d: -f1 | rev)
    old_sid=$(echo "$name" | rev | cut -d: -f2 | rev)

    # 2. Generate new UUID/SID
    local new_uuid new_sid
    new_uuid="$(generate_uuid)" || die "Failed to generate uuid"
    new_sid="$(generate_sid)" || die "Failed to generate sid"

    local new_name="${email}:${new_sid}:${level}"

    log_info "Resetting user $email (Level: $level)"
    log_info "Old SID: $old_sid -> New SID: $new_sid"

    local tmp_out
    tmp_out="$(mktemp)"

    # 3. Update JSON
    # Update the user entry with new name and uuid
    # Update the short_id list: remove old_sid, add new_sid
    jq --arg email "$email" \
        --arg old_sid "$old_sid" \
        --arg new_uuid "$new_uuid" \
        --arg new_sid "$new_sid" \
        --arg new_name "$new_name" \
        '
       .inbounds[0].users |= map(
         if (.name | startswith($email + ":")) then
           .uuid = $new_uuid | .name = $new_name
         else
           .
         end
       )
       | .inbounds[0].tls.reality.short_id |= (map(select(. != $old_sid)) + [$new_sid] | unique)
       ' "$input_file" >"$tmp_out" || die "jq failed during reset"

    mv "$tmp_out" "$STAGING_FILE"

    if [ "$no_apply" -eq 1 ]; then
        log_info "Staged reset for: $email"
    else
        apply_staging
        log_info "Reset user: $email"
    fi

    printf 'uuid: %s\nsid: %s\n' "$new_uuid" "$new_sid"
}

cmd_sni() {
    local target_sni="$1"

    # If using auto-detect, we need curl
    if [ -z "$target_sni" ]; then
        command -v curl >/dev/null || die "curl is required for SNI auto-detection."

        local sni_file="${MIMIC_NODE_ROOT}usr/share/mimic-node/sni.txt"
        if [ ! -f "$sni_file" ]; then
            die "SNI list file not found: $sni_file"
        fi

        log_info "Auto-detecting best SNI from $sni_file..."

        local best_fallback=""
        local checked_count=0

        while IFS= read -r cand || [ -n "$cand" ]; do
            # Skip comments and empty lines
            [[ "$cand" =~ ^#.*$ ]] && continue
            [[ -z "$cand" ]] && continue

            # Strip carriage returns if any
            cand="${cand%$'\r'}"

            ((checked_count++))
            # Progress indicator for large lists
            if ((checked_count % 5 == 0)); then
                echo -n "." >&2
            fi

            # 1. Connectivity check (IPv4 preferred for server outgoing)
            if ! curl -4 -s -I --connect-timeout 2 "https://${cand}" >/dev/null; then
                continue
            fi

            # 2. Reality check (if sing-box available)
            if [ "${HAS_SINGBOX:-0}" -eq 1 ]; then
                if sing-box check reality-dest "${cand}:443" >/dev/null 2>&1; then
                    target_sni="$cand"
                    echo "" >&2
                    log_info "Found perfect match: $cand"
                    break
                fi
            fi

            # 3. Fallback H2 check
            if [ -z "$best_fallback" ]; then
                if curl -4 -sI --http2 "https://${cand}" 2>&1 | grep -qE "HTTP/2|h2"; then
                    best_fallback="$cand"
                    # If sing-box is missing, we can't do better than H2 check
                    if [ "${HAS_SINGBOX:-0}" -eq 0 ]; then
                        target_sni="$cand"
                        echo "" >&2
                        log_info "Selected SNI (H2 supported): $cand"
                        break
                    fi
                fi
            fi
        done <"$sni_file"

        # Ensure newline if dots were printed and we didn't break early
        if [ -z "$target_sni" ] && [ "$checked_count" -ge 5 ]; then
            echo "" >&2
        fi

        if [ -z "$target_sni" ]; then
            if [ -n "$best_fallback" ]; then
                target_sni="$best_fallback"
                log_warn "No perfect Reality match found. Using fallback (H2 supported): $target_sni"
            else
                die "No reachable SNI found in candidates list."
            fi
        fi
    else
        log_info "Setting custom SNI: $target_sni"
    fi

    local input_file
    input_file=$(get_input_file)
    local tmp_out
    tmp_out="$(mktemp)"

    # Update config
    # We update both tls.server_name and tls.reality.handshake.server
    # Note: reality handshake server usually matches server_name (SNI)
    jq --arg sni "$target_sni" '
        .inbounds[0].tls.server_name = $sni |
        .inbounds[0].tls.reality.handshake.server = $sni
    ' "$input_file" >"$tmp_out" || die "jq failed during sni update"

    mv "$tmp_out" "$STAGING_FILE"

    apply_staging
    log_info "SNI updated to: $target_sni"
}

cmd_link() {
    local email
    local want_v4=0
    local want_v6=0
    local explicit_addrs=()

    # Parse flags and arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
        -v4)
            want_v4=1
            shift
            ;;
        -v6)
            want_v6=1
            shift
            ;;
        *)
            if [ -z "$email" ]; then
                email="$1"
            else
                explicit_addrs+=("$1")
            fi
            shift
            ;;
        esac
    done

    # Default to both if neither specified
    if [ "$want_v4" -eq 0 ] && [ "$want_v6" -eq 0 ]; then
        want_v4=1
        want_v6=1
    fi

    [ -n "$email" ] || die "Usage: $0 link [-v4] [-v6] <email> [addrs...]"

    local input_file
    input_file=$(get_input_file)

    # 1. Get User Info
    local user_entry
    user_entry=$(jq -r --arg email "$email" '.inbounds[0].users[] | select(.name | startswith($email + ":"))' "$input_file")

    if [ -z "$user_entry" ]; then
        die "User '$email' not found"
    fi

    local uuid flow name
    uuid=$(echo "$user_entry" | jq -r '.uuid')
    flow=$(echo "$user_entry" | jq -r '.flow')
    name=$(echo "$user_entry" | jq -r '.name')

    # Extract SID from name (email:sid:level)
    local sid
    sid=$(echo "$name" | rev | cut -d: -f2 | rev)

    # 2. Global Config
    local port sni
    port=$(jq -r '.inbounds[0].listen_port' "$input_file")
    sni=$(jq -r '.inbounds[0].tls.server_name' "$input_file")

    # Public Key
    local pbk
    if [ -f "$PUBKEY_FILE" ]; then
        pbk=$(cat "$PUBKEY_FILE" | tr -d '\n')
    else
        die "PUBKEY file not found. Cannot generate link."
    fi

    # 3. Determine Addresses & Sort
    local addrs_v4=()
    local addrs_v6=()

    if [ ${#explicit_addrs[@]} -gt 0 ]; then
        for addr in "${explicit_addrs[@]}"; do
            # Heuristic: if contains colon, assume v6
            if [[ "$addr" == *":"* ]]; then
                addrs_v6+=("$addr")
            else
                addrs_v4+=("$addr")
            fi
        done
    else
        # Auto detection
        if [ "$want_v4" -eq 1 ]; then
            if command -v curl >/dev/null 2>&1; then
                local v4
                v4=$(curl -s -4 --max-time 3 https://api.ipify.org || true)
                [ -n "$v4" ] && addrs_v4+=("$v4")
            fi
        fi
        if [ "$want_v6" -eq 1 ]; then
            if command -v curl >/dev/null 2>&1; then
                local v6
                v6=$(curl -s -6 --max-time 3 https://api6.ipify.org || true)
                [ -n "$v6" ] && addrs_v6+=("$v6")
            fi
        fi

        # Fallback only if BOTH empty (and no explicit addresses)
        if [ ${#addrs_v4[@]} -eq 0 ] && [ ${#addrs_v6[@]} -eq 0 ]; then
            log_warn "Could not detect public IP. Using placeholder."
            addrs_v4+=("<YOUR_SERVER_IP>")
        fi
    fi

    # 4. Construct Links
    # Encode name
    local safe_name
    safe_name=$(jq -rn --arg x "$name" '$x|@uri')

    local links_json="[]"

    # Helper function to append link to JSON array
    add_link_json() {
        local addr="$1"
        local host_formatted="$addr"
        # IPv6 bracket handling
        if [[ "$addr" == *":"* ]] && [[ "$addr" != *"["* ]]; then
            host_formatted="[${addr}]"
        fi

        local link="vless://${uuid}@${host_formatted}:${port}?security=reality&encryption=none&pbk=${pbk}&fp=chrome&type=tcp&sni=${sni}&sid=${sid}&flow=${flow}#${safe_name}"
        links_json=$(echo "$links_json" | jq --arg link "$link" '. + [$link]')
    }

    # Iterate V4 then V6 to ensure sorting order
    for addr in "${addrs_v4[@]}"; do
        add_link_json "$addr"
    done
    for addr in "${addrs_v6[@]}"; do
        add_link_json "$addr"
    done

    # 5. Output JSON Array
    echo "$links_json"
}

cmd_list() {
    local filter="$1"
    local input_file
    input_file=$(get_input_file)

    if [ -n "$filter" ]; then
        # Filter by string match on name
        jq -r --arg filter "$filter" '.inbounds[0].users[] | select(.name | contains($filter)) | "\(.name)\t\(.uuid)\t\(.flow)"' "$CONFIG_FILE" || log_warn "No users found matching '$filter'"
    else
        jq -r '.inbounds[0].users[] | "\(.name)\t\(.uuid)\t\(.flow)"' "$CONFIG_FILE" || log_warn "No users found"
    fi
}

cmd_info() {
    local email="$1"
    [ -n "$email" ] || die "Usage: $0 info <email>"

    # Use jq to find the user.
    # We look for name starting with "email:"
    local user_json
    user_json=$(jq --arg email "$email" '.inbounds[0].users[] | select(.name | startswith($email + ":"))' "$CONFIG_FILE")

    if [ -z "$user_json" ] || [ "$user_json" == "null" ]; then
        log_warn "User not found: $email"
        exit 1
    fi

    echo "$user_json"
}

cmd_show() {
    echo "Config ($CONFIG_FILE):"
    jq '.' "$CONFIG_FILE"
    echo
    echo "PUBKEY ($PUBKEY_FILE):"
    if [ -f "$PUBKEY_FILE" ]; then
        cat "$PUBKEY_FILE"
    else
        log_warn "PUBKEY not found: $PUBKEY_FILE"
    fi
}

cmd_help() {
    cat <<'EOF'
mimictl - control tool for Mimic-Node

Usage:
  mimictl help                       Show this help.
  mimictl gen-keys                   Generate reality keypair and apply to config.
  mimictl add [--no-apply] <email>   Add a new user. Use --no-apply to batch.
  mimictl del [--no-apply] <email>   Remove a user by email. Use --no-apply to batch.
  mimictl reset [--no-apply] <email> Reset UUID and SID for a user.
  mimictl sni [domain]               Set or auto-detect best Reality SNI server.
  mimictl link [-v4] [-v6] <email> [addrs...]
                                     Generate VLESS share links (JSON array).
                                     Auto-detect IP if omitted. -v4/-v6 filters auto-detection.
  mimictl list [filter]              List users (optionally filter by name).
  mimictl info <email>               Show details for a specific user.
  mimictl show                       Show current config and PUBKEY.
  mimictl apply                      Apply staged changes (from batch operations).

Examples:
  # Get subscription links (auto-detect IPv4/IPv6, output JSON array of links)
  mimictl link alice@example.com

  # Get IPv4 only
  mimictl link -v4 alice@example.com

  # Explicit addresses (sorted v4 first in output)
  mimictl link alice@example.com 2001::1 1.2.3.4

  # Auto-detect and set best SNI
  mimictl sni

  # Set custom SNI
  mimictl sni www.google.com

  # Filter users
  mimictl list "alice"

  # Reset user credentials
  mimictl reset alice@example.com

  # Batch add users
  mimictl add --no-apply alice@example.com
  mimictl add --no-apply bob@example.com
  mimictl apply
EOF
}

# --- Dispatch ---
case "${1:-help}" in
help | -h | --help) cmd_help ;;
gen-keys | gen | keys) cmd_gen_keys ;;
add)
    shift
    cmd_add "$@"
    ;;
del | delete | remove | rm)
    shift
    cmd_del "$@"
    ;;
reset)
    shift
    cmd_reset "$@"
    ;;
sni)
    shift
    cmd_sni "$@"
    ;;
link)
    shift
    cmd_link "$@"
    ;;
list | ls)
    shift
    cmd_list "$@"
    ;;
info)
    shift
    cmd_info "$@"
    ;;
show) cmd_show ;;
apply) apply_staging ;;
*)
    cmd_help
    exit 1
    ;;
esac
